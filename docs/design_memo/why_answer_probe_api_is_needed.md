# 設計 Memo

## なぜ Answer Probe API（pytest 向け接点）が必要になったのか

- Project: gov-llm-e2e-testkit
- Context: Phase B — Basic RAG Test v0.1 実装開始
- Date: 2025-12-14
- Status: 設計理解メモ（非仕様・非拘束）

---

## 1. このメモの目的

本メモは、
**「なぜ `answer_probe` のような API（pytest から呼べる接点）を作る話になったのか」**
という設計上の流れを、後から読み返して理解できる形で残すためのものである。

これは新機能提案でも、正式仕様でもない。
**設計の必然性を記録するための開発メモ**である。

---

## 2. 結論（先に）

- `answer_probe` は **新しい機能ではない**
- すでに存在する **Answer Detection Layer（probe v0.2.x）** を
  pytest から **正規に・責務を壊さず**利用するための
  *最小の接点* を切り出そうとしているだけである
- 「API」という言葉は
  **pytest から呼んでよい Python 関数**という意味で使っている

---

## 3. すでに存在しているもの（一次事実）

Phase A までに、以下はすでに存在している：

- Answer Detection Layer（probe v0.2.x）の設計
- submit–probe correlation 設計
- GraphQL / REST を含む回答検知ロジック
- `run_probe_once.py` 等の **人間実行用スクリプト**
- sandbox / scripts による検証資産

つまり：

> **「回答を検知する仕組み」自体はすでに完成している**

---

## 4. 存在していなかったもの

一方で、Phase B（RAG QA 自動化）に入った時点で
**初めて問題として顕在化したもの**がある。

それは：

- pytest から直接呼べる
  **責務が固定された関数（正式な接点）**

例：

```python
answer_text = wait_for_answer_text(
    submit_id=...,
    chat_id=...,
    timeout_sec=...
)
```

これまで probe は：

- 人が実行する
- ログを見る
- 設計検証を行う

という用途だったため、
**テストコード（pytest）からの利用は想定されていなかった**。

---

## 5. なぜ「API」という話になったのか

ここで言う「API」は：

- Web API ではない
- 外部公開インターフェースでもない
- 大規模な抽象レイヤでもない

意味しているのは：

> **pytest から呼んでよい、
> 責務と入出力が固定された Python 関数**

である。

pytest という「新しい利用者」が現れたことで、

- Test Layer と
- Answer Detection Layer

の間に、**正式な接点が必要になった**。

---

## 6. 責務マップ上での位置づけ

責務境界を図示すると以下の関係になる：

```text
[ Application Test Layer ]
    test_rag_basic_v0_1.py
            |
            |  ← 回答テキストが欲しい
            v
[ Answer Detection Layer ]
    probe v0.2.x
            |
            |  ← 既存だが、人間用
            v
[ scripts / sandbox ]
    run_probe_once.py
```

問題点は：

- Test Layer から見たとき
  **「どうやって答えを取得すればよいか」が未定義**

これを解消するために：

- probe の責務を壊さず
- 内部構造を晒さず
- 最小の I/O だけを提供する

接点（関数）が必要になった。

これを便宜的に **answer_probe API** と呼んでいる。

---

## 7. 代替案と却下理由（設計判断）

検討可能だった案：

### ❌ pytest から `run_probe_once.py` を subprocess 実行

- 人間用エントリポイントであり責務不適合
- エラー理由・観測事実が曖昧になる

### ❌ test_rag_basic から probe 内部構造を直接参照

- 責務境界を破壊する
- probe の変更に極端に弱くなる

### ✅ probe の観測結果を返す最小関数を切り出す

- 現行設計思想と完全一致
- Test Layer が probe 実装詳細から独立できる

---

## 補足：例規HTML変換プロジェクトとの関係（文脈の明示）

本設計判断は、gov-llm-e2e-testkit 単体の都合だけで生じたものではない。
背景には、**例規HTML変換プロジェクトのテスト自動化**という
明確な上位目的が存在する。

### 背景となる目的

- 例規（条例・規則）HTML を構造化データへ変換する
- 変換結果を RAG 用ナレッジとして投入する
- LLM がそのナレッジを **正しく参照して回答できているか**を検証したい
- この検証を **人手ではなく自動テスト（pytest / CI）で行いたい**

このとき、必要になるのは：

- UI 操作の成否ではなく
- モデルの意味理解でもなく
- **「実際に返された回答テキスト」そのもの**

である。

---

### なぜ pytest から probe を呼びたいのか

例規HTML変換プロジェクトのテストでは：

- 人がログを眺めて判断する前提は使えない
- CI 上で PASS / FAIL を機械的に決める必要がある
- UI テストは副次的であり、本質ではない

そのため、pytest から：

1. 質問を送信し（submit）
2. 回答を検知し（probe）
3. 回答テキストを取得する

という流れを **直接・安定的に実行できる必要がある**。

---

### answer_probe の位置づけ（誤解防止）

この文脈において answer_probe は：

- probe をバイパスする「近道」ではない
- 勝手口やハックではない
- probe の責務を再実装するものでもない

むしろ：

> **pytest という新しい利用者のために設けられた
> “職員専用の正規入口”**

である。

これにより：

- 例規HTML変換プロジェクトのテストコードは
  probe の内部構造に依存せず
- Answer Detection Layer の進化にも耐え
- gov-llm-e2e-testkit を **共通テスト基盤として再利用可能**になる

---

### 本補足の位置づけ

本節は、

- answer_probe API を「なぜ作るか」ではなく
- **「どの文脈・どの上位目的のために必要になったか」**

を明示するための補足である。

この理解が共有されていない状態で
answer_probe の実装だけが残ると、
将来「なぜこんな入口があるのか」が分からなくなるため、
設計判断ログとしてここに記録する。

---

## 4️⃣ 追記後の文書の性格（重要）

このメモは最終的に：

- 仕様書 ❌
- 実装指示書 ❌
- README ❌

ではなく、

> **「あとから設計を振り返るための判断ログ」**

になります。

これは
**AIと人間が共同で設計したプロジェクトにおいて、特に価値が高い文書**です。

---

## 8. 「急に生えた感」の正体

違和感の正体は以下である：

- probe はずっと存在していた
- ただし **利用者が人間だった**
- Phase B から **pytest が利用者になった**

つまり：

> **新しい機能が増えたのではなく、
> 既存の仕組みが「自動テスト部品」に昇格した**

というだけである。

---

## 9. 重要な注意点

- この段階では **実装はまだ不要**
- まずやるべきは
  **pytest から見た最小 I/O を設計で確定させること**
- ダミー実装や仮 return を作るのは
  Phase B の品質を壊すため避ける

---

## 10. まとめ

- answer_probe は新機能ではない
- 既存 probe の責務を
  pytest から安全に使うための整理である
- Phase B に入ったことで
  **必然的に必要になった接点**である
- この理解を共有・保存するため、本メモを残す

---
